<!DOCTYPE html>
<html>
<head>
    <title>Three.js 2D推箱子游戏</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info { position: absolute; top: 10px; left: 10px; color: white; }
    </style>
</head>
<body>
    <div id="info">方向键移动，R键重置关卡</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, player;
        const TILE_SIZE = 40;
        const level = [
            [1,1,1,1,1,1],
            [1,0,0,0,0,1],
            [1,0,2,3,0,1],
            [1,0,0,1,0,1],
            [1,1,1,1,1,1]
        ];
        let boxes = [];
        let targets = [];

        // 初始化场景[1,3](@ref)
        function init() {
            scene = new THREE.Scene();
            
            // 正交相机配置[1](@ref)
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera = new THREE.OrthographicCamera(
                width / -2, width / 2,
                height / 2, height / -2,
                1, 1000
            );
            camera.position.set(0, 300, 0);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            document.body.appendChild(renderer.domElement);

            // 创建棋盘格地面[3](@ref)
            const gridHelper = new THREE.GridHelper(400, 40);
            gridHelper.rotation.x = Math.PI / 2;
            scene.add(gridHelper);

            // 初始化游戏元素
            initElements();
            animate();
        }

        // 创建游戏元素[1,3](@ref)
        function initElements() {
            // 生成墙体和目标点
            for(let y=0; y<level.length; y++) {
                for(let x=0; x<level[y].length; x++) {
                    const val = level[y][x];
                    if(val === 1) createWall(x, y);
                    if(val === 3) createTarget(x, y);
                }
            }

            // 创建玩家[3](@ref)
            const geometry = new THREE.BoxGeometry(30, 30, 30);
            const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
            player = new THREE.Mesh(geometry, material);
            player.position.set(2*TILE_SIZE, 15, 2*TILE_SIZE);
            scene.add(player);

            // 创建箱子[1](@ref)
            createBox(3, 2);
        }

        function createWall(x, y) {
            const geometry = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
            const material = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const wall = new THREE.Mesh(geometry, material);
            wall.position.set(x*TILE_SIZE, TILE_SIZE/2, y*TILE_SIZE);
            scene.add(wall);
        }

        function createTarget(x, y) {
            const geometry = new THREE.RingGeometry(10, 15, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                side: THREE.DoubleSide
            });
            const target = new THREE.Mesh(geometry, material);
            target.rotation.x = -Math.PI/2;
            target.position.set(x*TILE_SIZE, 1, y*TILE_SIZE);
            scene.add(target);
            targets.push({x, y});
        }

        function createBox(x, y) {
            const geometry = new THREE.BoxGeometry(30, 30, 30);
            const material = new THREE.MeshPhongMaterial({ color: 0xffff00 });
            const box = new THREE.Mesh(geometry, material);
            box.position.set(x*TILE_SIZE, 15, y*TILE_SIZE);
            scene.add(box);
            boxes.push({ mesh: box, x, y });
        }

        // 移动逻辑[2,4](@ref)
        function movePlayer(dx, dz) {
            const newX = (player.position.x / TILE_SIZE) + dx;
            const newZ = (player.position.z / TILE_SIZE) + dz;

            if(isValidPosition(newX, newZ)) {
                player.position.x += dx * TILE_SIZE;
                player.position.z += dz * TILE_SIZE;
            }
        }

        function isValidPosition(x, z) {
            const y = Math.round(z);
            x = Math.round(x);
            
            if(x < 0 || x >= level[0].length) return false;
            if(y < 0 || y >= level.length) return false;
            
            // 检查墙体碰撞[1](@ref)
            if(level[y][x] === 1) return false;

            // 检查箱子推动
            const box = boxes.find(b => b.x === x && b.y === y);
            if(box) {
                const newBoxX = x + (x - box.x);
                const newBoxY = y + (y - box.y);
                if(isValidPosition(newBoxX, newBoxY)) {
                    box.mesh.position.x = newBoxX * TILE_SIZE;
                    box.mesh.position.z = newBoxY * TILE_SIZE;
                    box.x = newBoxX;
                    box.y = newBoxY;
                    checkWin();
                    return true;
                }
                return false;
            }
            return true;
        }

        function checkWin() {
            const win = targets.every(t => 
                boxes.some(b => b.x === t.x && b.y === t.y)
            );
            if(win) alert("恭喜通关！");
        }

        // 事件监听[2](@ref)
        document.addEventListener('keydown', (e) => {
            const keyMap = {
                ArrowUp: [0, -1],
                ArrowDown: [0, 1],
                ArrowLeft: [-1, 0],
                ArrowRight: [1, 0],
                r: () => location.reload()
            };
            
            if(keyMap[e.key]) {
                e.preventDefault();
                if(typeof keyMap[e.key] === 'function') {
                    keyMap[e.key]();
                } else {
                    movePlayer(...keyMap[e.key]);
                }
            }
        });

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>