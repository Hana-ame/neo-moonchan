<!DOCTYPE html>
<html>

<head>
    <style>
        /* 新增父级容器透视 */
        body {
            perspective: 1200px;
            /* 增强3D纵深感[1,2](@ref) */
            min-height: 100vh;
            display: grid;
            place-items: center;
        }

        .character {
            width: 300px;
            transition:
                opacity 0.3s ease-out,
                transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            /* 平滑曲线 */
            transform-style: preserve-3d;
            cursor: pointer;
            filter: drop-shadow(0 10px 15px rgba(0, 0, 0, 0.3));
            /* 增加立体投影 */
        }

        /* 悬停时透明度与初始角度 */
        .character:hover {
            opacity: 1 !important;
            transform: rotateY(15deg) rotateX(10deg) scale(1.1);
            /* 初始倾斜角度[4](@ref) */
        }
    </style>
</head>

<body>
    <img src="https://proxy.moonchan.xyz/bfs/archive/83a2be18da056ff6ba702a4f174ff17b00aef39d.jpg?proxy_host=i1.hdslb.com"
        class="character" style="opacity:0.7;" />

    <style>
        .card-container {
            perspective: 1000px;
            width: 300px;
            height: 430px;
        }

        .card {
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            backface-visibility: hidden;
        }

        .card-back {
            transform: rotateY(0deg);
        }

        .card-front {
            transform: rotateY(180deg);
        }

        /* 新增以下规则 */
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            /* 强制开启GPU加速 */
            transform: translateZ(1px);
        }

        .card-back {
            background: #FF9800;
            z-index: 2;
            /* 背面初始层级更高 */
        }

        .card-front {
            transform: rotateY(180deg);
            z-index: 1;
            /* 正面初始层级更低 */
        }

        .card.flipped .card-front {
            z-index: 3;
            /* 翻转后正面层级提升 */
        }
    </style>

    <div class="card-container" onclick="this.querySelector('.card').classList.toggle('flipped')">
        <svg class="card" width="300" height="430">
            <!-- 背面 -->
            <g class="card-face card-back">
                <image      
                    src="https://proxy.moonchan.xyz/bfs/archive/83a2be18da056ff6ba702a4f174ff17b00aef39d.jpg?proxy_host=i1.hdslb.com"
                    class="img" style="opacity:0.7;" />
            </g>
            <!-- 正面 -->
            <g class="card-face card-front">
                <rect width="300" height="430" fill="#FF9800" />
            </g>
        </svg>
    </div>
    <div class="card-container" onclick="this.querySelector('.card').classList.toggle('flipped')">
        <svg class="card" width="300" height="430">
            <!-- 背面 -->
            <foreignObject width="100%" height="100%">
                <image
                    src="https://proxy.moonchan.xyz/bfs/archive/83a2be18da056ff6ba702a4f174ff17b00aef39d.jpg?proxy_host=i1.hdslb.com"
                    style="width:100%; height:100%; opacity:0.7;" />
            </foreignObject>
            <!-- 正面 -->
            <foreignObject width="100%" height="100%">
                <rect width="300" height="430" fill="#FF9800" />
            </foreignObject>
        </svg>
    </div>
    <script>
        // 动态视角绑定（45°极限角度）
        document.querySelector('.character').addEventListener('mousemove', (e) => {
            const rect = e.target.getBoundingClientRect();
            const sensitivity = 45; // 角度灵敏度系数

            // 计算标准化坐标（-0.5到+0.5）
            const x = ((e.clientX - rect.left) / rect.width - 0.5) * sensitivity;
            const y = ((e.clientY - rect.top) / rect.height - 0.5) * -sensitivity;

            // 动态变换公式
            e.target.style.transform = `
        rotateY(${x}deg) 
        rotateX(${y}deg) 
        scale(1.05)
        translateZ(30px)  /* 增加Z轴位移强化立体感[2](@ref) */
      `;

            // 动态透明度计算（离中心越远透明度越高）
            const distance = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
            e.target.style.opacity = 0.7 + Math.min(distance / 100, 0.3);
        });
    </script>
</body>

</html>